{
  "category": {
        "name" : "Множества",
        "key" : "Set",
        "isEnable" : true
  },
  "question" : [
    {
        "id": 1201,
        "textQuestion": "Каким должен быть тип значения, чтобы он мог храниться в множестве?",
        "answers": [
          {
            "correctAnswer" : true,
            "textAnswer": "Хешируемым"
          },
          {
            "textAnswer": "Булевым"
          },
          {
            "textAnswer": "Вычисляемым"
          },
          {
            "textAnswer": "Числовым"
          }
        ],
        "hint": "Хешируемым. Тип значений должен быть хешируемым для того, чтобы он мог храниться в множестве, таким образом тип должен предстовлять возможность для вычисления собственного значения хеша."
    },
    {
        "id": 1202,
        "textQuestion": "Как в Swift записывается тип множества?",
        "answers": [
          {
            "textAnswer": "(Set<ElementType>)"
          },
          {
            "correctAnswer" : true,
            "textAnswer": "Set<ElementType>"
          },
          {
            "textAnswer": "Set(ElementType)"
          },
          {
            "textAnswer": "Set[ElementType]"
          }
        ],
        "hint": "Set<ElementType>. Тип множества в Swift записывается как Set<ElementType>, ElementType является типом, который хранится в множестве"
    },
    {
        "id": 1203,
        "textQuestion": "Имеют ли множества сокращенную форму записи, если да, то какую?",
        "answers": [
          {
            "textAnswer": "Да, (Set)"
          },
          {
            "correctAnswer" : true,
            "textAnswer": "Нет"
          },
          {
            "textAnswer": "Да, <Set>"
          }
        ],
        "hint": "В отличии от массива множества не имеют сокращенной формы записи. Кроме случаев инициализации через литерал массива, где содержатся элементы одного и того-же типа, в таком случае монжо писать просто Set, без указания конкретного типа."
        
    },
    {
        "id": 1204,
        "textQuestion": "Как создать пустое множество конкретного типа?",
        "answers": [
          {
            "textAnswer": "= Array<String>[]"
          },
          {
            "correctAnswer" : true,
            "textAnswer": "= Set<String>()"
          },
          {
            "textAnswer": "= Dictionary<String>()"
          }
        ],
        "hint": "= Set<String>(). Вы можете создать пустое множество конкретного типа, используя синтаксис инициализатора. var name = Set<String>()"
    },
    {
        "id": 1205,
        "textQuestion": "Если контекст дает информацию о типе, можем ли мы создать пустое множество при помощи литерала пустого массива?",
        "answers": [
          {
            "textAnswer": "Нет"
          },
          {
            "correctAnswer" : true,
            "textAnswer": "Да"
          }
        ],
        "hint": "Да. Альтернативно, если контекст предоставляет информацию о типе, например как аргумент функции иил просто явное указание типа переменной или константы, то вы можете создать пустое множество при помощи пустого литерала массива."
    },
    {
        "id": 1206,
        "textQuestion": "Можем ли мы инициализировать множество при помощи литерала массива",
        "answers": [
          {
            "correctAnswer" : true,
            "textAnswer": "Да, let ints: Set<Int> = [1,2]"
          },
          {
            "textAnswer": "Да, let ints: Set<Int>([1,2])"
          },
          {
            "textAnswer": "Да, let ints = Set<Int[1,2]>"
          },
          {
            "textAnswer": "Нет"
          }
        ],
        "hint": "Да, let ints: Set<Int> = [1,2]. Вы можете инициализировать множество при помощи литерала массива, чтобы использовать его в качестве сокращенной записи нескольких элементов множества."
    },
    {
        "id": 1207,
        "textQuestion": "Если попытаться удалить элемент множества, которго в нем нет, что мы получим?",
        "answers": [
          {
            "textAnswer": "Первый элемент множества"
          },
          {
            "correctAnswer" : true,
            "textAnswer": "nil"
          },
          {
            "textAnswer": "Последний элемент множества"
          }
        ],
        "hint": "nil. Вы можете удалить элемент из множествав, используя метод remove(), который удаляет элемент, который является членом множества и возвращает удаленное значение или nil, если его нету."
    },
    {
        "id": 1208,
        "textQuestion": "У множества нет порядка, поэтому, чтобы удобнее его итерировать, используется этот метод с циклом for-in?",
        "answers": [
          {
            "textAnswer": ".flatMap()"
          },
          {
            "textAnswer": ".filter()"
          },
          {
            "textAnswer": ".sort()"
          },
          {
            "correctAnswer" : true,
            "textAnswer": ".sorted()"
          }
        ],
        "hint": "sorted(). Множества в Swift не имеют определенного порядка. Для того, чтобы провести итерацию по множеству в определенном порядке, вам нужно использовать метод sorted(), который возвращает вам элементы коллекции в виде отсортированного массива, используя операторы < или >"
    },
    {
        "id": 1210,
        "textQuestion": "Какой метод поможет определить, все ли значения множества содержатся в указанном множестве?",
        "answers": [
          {
            "textAnswer": "isSuperset(of:)"
          },
          {
            "correctAnswer" : true,
            "textAnswer": "isSubset(of:)"
          }
        ],
        "hint": "isSubset(of:). Используйте метод isSubset(of:) для определения все ли значения множества содержатся в указанном множестве."
    },
    {
        "id": 1211,
        "textQuestion": "Какой метод поможет определить, содержит ли множество все значения указанного множества?",
        "answers": [
          {
            "correctAnswer" : true,
            "textAnswer": "isSuperset(of:)"
          },
          {
            "textAnswer": "isSubset(of:)"
          },
          {
            "textAnswer": "isStrictSubset(of:)"
          }
        ],
        "hint": "isSuperset(of:). Используйте метод isSuperset(of:) чтобы определить содержит ли множество все значения указанного множества."
    }
  ]
}
