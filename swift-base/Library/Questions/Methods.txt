{
  "category": {
        "name" : "Методы",
        "key" : "Methods",
        "countOfQuestions" : 21,
        "isEnable" : true
  },
  "question" : [
    {
        "id": 1101,
        "textQuestion": "Чем отличаются методы от функций?",
        "answers": [
          {
            "correctAnswer" : true,
            "textAnswer": "Методы связаны с типами"
          },
          {
            "textAnswer": "Методы нельзя объявлять в классах"
          },
          {
            "textAnswer": "Методы глобальнее функций"
          },
          {
            "textAnswer": "Функции привязаны к типами"
          }
        ],
        "hint": "Методы связаны с типами. Методы - это функции, которые связаны с определенным типом. Классы, структуры и перечисления - все они могут определять методы экземпляра, которые включают в себя определенные задачи и функциональность для работы с экземпляром данного типа."
    },
    {
        "id": 1102,
        "textQuestion": "Могут ли классы определять методы типа?",
        "answers": [
          {
            "correctAnswer" : true,
            "textAnswer": "Да"
          },
          {
            "textAnswer": "Нет"
          }
        ],
        "hint": "Классы, структуры и перечисления так же могут определить методы типа, которые связаны с самим типом. Методы типа работают аналогично методами класса в Objective-C."
    },
    {
        "id": 1103,
        "textQuestion": "Могут ли классы определять методы типа?",
        "answers": [
          {
            "correctAnswer" : true,
            "textAnswer": "Да"
          },
          {
            "textAnswer": "Нет"
          }
        ],
        "hint": "Да. Дело в том, что структуры и перечисления могут определить методы в Swift, что является главным отличием от C или Objective-C. В Objective-C классы единственный тип, который может определять методы."
    },
    {
        "id": 1104,
        "textQuestion": "Методы экземпляра класса и функции имеют одинаковый синтаксис?",
        "answers": [
          {
            "correctAnswer" : true,
            "textAnswer": "Да"
          },
          {
            "textAnswer": "Нет"
          }
        ],
        "hint": "Да. Методы экземлпяра являются функциями, которые принадлежат экземплярам конкретного класса, структуры или перечисления."
    },
    {
        "id": 1105,
        "textQuestion": "Где записываются метод экземпляра?",
        "answers": [
          {
            "textAnswer": "В расширении вашего типа"
          },
          {
            "correctAnswer" : true,
            "textAnswer": "Внутри {} вашего типа"
          },
          {
            "textAnswer": "В имени вашего типа"
          },
          {
            "textAnswer": "В протоколе вашего типа"
          }
        ],
        "hint": "Внутри {} вашего типа. Вы пишете метод экземпляра внутри фигурных скобок типа, которому он принадлежит."
    },
    {
        "id": 1106,
        "textQuestion": "Имеет ли метод экземпляра доступ к остальным методам экземпляра и свойствам этого типа?",
        "answers": [
          {
            "textAnswer": "Неявно только к методам"
          },
          {
            "textAnswer": "Неявно только к свойствам"
          },
          {
            "textAnswer": "Нет"
          },
          {
            "correctAnswer" : true,
            "textAnswer": "Да"
          }
        ],
        "hint": "Да. Метод экземпляра имеет неявный доступ ко всем остальным методам экземпляра и свойствам этого типа."
    },
    {
        "id": 1107,
        "textQuestion": "Можем ли мы вызывать метод экземпляра в изоляции, без самого экземпляра этого типа?",
        "answers": [
          {
            "correctAnswer" : true,
            "textAnswer": "Нет"
          },
          {
            "textAnswer": "Да"
          }
        ],
        "hint": "Нет. Метод экземпляра может быть вызван только для конкретного экземпляра типа, которому он принадлежит. Его нельзя вызвать в изоляции, без существующего экземпляра."
    },
    {
        "id": 1108,
        "textQuestion": "Через какой синтаксис вызываются методы экземпляра класса?",
        "answers": [
          {
            "textAnswer": "Литеральный синтаксис"
          },
          {
            "textAnswer": "Синтаксис иницализации"
          },
          {
            "correctAnswer" : true,
            "textAnswer": "Точечный синтаксис"
          },
          {
            "textAnswer": "Синтаксис сабскриптов"
          }
        ],
        "hint": "Точечный синтаксис. Вы можете вызвать методы экземпляра с тем же точечным синтаксисом, как и свойствам."
    },
    {
        "id": 1109,
        "textQuestion": "Через какой синтаксис вызываются методы экземпляра класса?",
        "answers": [
          {
            "textAnswer": "Литеральный синтаксис"
          },
          {
            "textAnswer": "Синтаксис иницализации"
          },
          {
            "correctAnswer" : true,
            "textAnswer": "Точечный синтаксис"
          },
          {
            "textAnswer": "Синтаксис сабскриптов"
          }
        ],
        "hint": "Точечный синтаксис. Вы можете вызвать методы экземпляра с тем же точечным синтаксисом, как и свойствам."
    },
    {
        "id": 1110,
        "textQuestion": "Может ли метод экземпляра иметь имя аргумента и ярлык аргумента одновременно?",
        "answers": [
          {
            "textAnswer": "Нет, только имя"
          },
          {
            "correctAnswer" : true,
            "textAnswer": "Да"
          },
          {
            "textAnswer": "Нет, только ярлык"
          }
        ],
        "hint": "Да. Параметры функции могут иметь и имя аргумента и ярлык аргумента. То же самое верно для имен параметров методовб потому как методы те же самые функции, но ассоциированные с определенным типом."
    },
    {
        "id": 1111,
        "textQuestion": "Для чего необходимо использовать неявное свойство self?",
        "answers": [
          {
            "correctAnswer" : true,
            "textAnswer": "Для ссылки на текущий экземпляр"
          },
          {
            "textAnswer": "Для ссылки на другой экземпляр"
          }
        ],
        "hint": "Для ссылки на текущий экземпляр. Каждый экземпляр типа имеет неявное свойство self. которое является абсолютным эквивалентом самому экземпляру. Вы используете свойство для self для ссылки на текущий экземпляр, внутри методов этого экземпляра"
    },
    {
        "id": 1112,
        "textQuestion": "Если мы находимся не внутри функции или метода, обязаны ли мы употреблять self постоянно?",
        "answers": [
          {
            "textAnswer": "Да"
          },
          {
            "correctAnswer" : true,
            "textAnswer": "Нет"
          }
        ],
        "hint": "Нет. На практике вам не нужно писать self очень часто. Если вы не пишите self, то Swift полагает, что вы ссылаетесь на свойство или метод текущего экземпляра каждый раз, когда вы используете известное имя свойство или метода внутри метода"
    },
    {
        "id": 1113,
        "textQuestion": "Каким типом являются структуры и перечисления?",
        "answers": [
          {
            "correctAnswer" : true,
            "textAnswer": "Ссылочный тип"
          },
          {
            "textAnswer": "Тип значений"
          }
        ],
        "hint": "Тип значений. Структуры и перечисления являются типами значений."
    },
    {
        "id": 1114,
        "textQuestion": "После указания этого ключевого слова к методу структуры или перечисления, он может изменить свои свойства изнутри метода?",
        "answers": [
          {
            "textAnswer": "private"
          },
          {
            "textAnswer": "static"
          },
          {
            "correctAnswer" : true,
            "textAnswer": "mutating"
          },
          {
            "textAnswer": "public"
          }
        ],
        "hint": "mutating. Если вам нужно изменить свойства вашей структуры или перечисления изнутри конкретного метода, то вы можете выбрать поведения как изменяющееся для этого метода."
    },
    {
        "id": 1115,
        "textQuestion": "Если наш экземпляр структуры является константой, можем ли мы вызывать изменяющиеся методы?",
        "answers": [
          {
            "correctAnswer" : true,
            "textAnswer": "Нет"
          },
          {
            "textAnswer": "Если свойства - переменные"
          },
          {
            "textAnswer": "Да"
          }
        ],
        "hint": "Нет. Вы не можете вызвать изменяющийся метод для констатных типов структур, потому как ее свойства не могут быть изменены, даже если свойства являются переменными."
    },
    {
        "id": 1116,
        "textQuestion": "Могут ли изменяющие методы присваивать полностью новый экземпляр неявному свойству self?",
        "answers": [
          {
            "textAnswer": "Нет"
          },
          {
            "correctAnswer" : true,
            "textAnswer": "Да"
          }
        ],
        "hint": "Да. Изменяющие методы могут присваивать полностью новый экземпляр неявному свойству self"
    },
    {
        "id": 1117,
        "textQuestion": "Могут ли изменяющие методы перечислений устанавливать отдельный член перечисления как неявный параметр self?",
        "answers": [
          {
            "textAnswer": "Нет"
          },
          {
            "correctAnswer" : true,
            "textAnswer": "Да"
          }
        ],
        "hint": "Да. Изменяющие методы для перечислений могут установить отдельный член перечисления как неявный параметр self"
    },
    {
        "id": 1118,
        "textQuestion": "Каким ключевым словом определить методы типа?",
        "answers": [
          {
            "textAnswer": "public"
          },
          {
            "textAnswer": "class"
          },
          {
            "correctAnswer" : true,
            "textAnswer": "static"
          },
          {
            "textAnswer": "fileprivate"
          }
        ],
        "hint": "static. Вы можете определить методы, которые вызываются самим типом. Такие методы зовутся методами типа. Индикатор такого метода - ключевое слово static, которое ставится до ключевого слова метода func."
    },
    {
        "id": 1119,
        "textQuestion": "Можем ли мы создавать методы типа для классов, структур и перечислений?",
        "answers": [
          {
            "textAnswer": "Нет"
          },
          {
            "correctAnswer" : true,
            "textAnswer": "Да"
          }
        ],
        "hint": "Да. В Objective-C определять методы типов можно только для классов. В Swift вы можете создавать методы типа не только для классов, но и для структур и перечислений. Метод каждого типа ограничен самим типом, который он поддерживает."
    },
    {
        "id": 1120,
        "textQuestion": "Можем ли мы использовать точечный синтаксис для обращения к методам типа?",
        "answers": [
          {
            "correctAnswer" : true,
            "textAnswer": "Да"
          },
          {
            "textAnswer": "Нет"
          }
        ],
        "hint": "Да.Методы типа так же используют точечный синтаксис, как и методы экземпляра. Однако эти методы вы вызываете самим типом, а не экземпляром этого типа"
    },
    {
        "id": 1121,
        "textQuestion": "Можем ли мы использовать точечный синтаксис для обращения к методам типа?",
        "answers": [
          {
            "correctAnswer" : true,
            "textAnswer": "Да"
          },
          {
            "textAnswer": "Нет"
          }
        ],
        "hint": "Да.Методы типа так же используют точечный синтаксис, как и методы экземпляра. Однако эти методы вы вызываете самим типом, а не экземпляром этого типа"
    }
  ]
}
