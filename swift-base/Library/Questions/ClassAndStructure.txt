{

"category": {

"name" : "Классы и структуры",

"countOfQuestions" : 21,

"key" : "ClassAndStructure",

"isEnable" : true

},

"question" : [

{

"id": 1301,

"textQuestion": "Каким ключевыми словами обозначаются структуры и классы в коде?",

"answers": [

{

"textAnswer": "class и structures"

},

{

"textAnswer": "classes и struct"

},

{

"textAnswer": "classes и structures"

},

{

"correctAnswer" : true,

"textAnswer": "class и struct"

}

],

"hint": "class и struct. Классы и структуры имеют схожий синтаксис обьявлений."

},

{

"id": 1302,

"textQuestion": "Что можно объявить внутри классов и структур для добавления функциональности?",

"answers": [

{

"correctAnswer" : true,

"textAnswer": "Свойства и методы"

},

{

"textAnswer": "Функции и замыкания"

},

{

"textAnswer": "Комментарии"

},

{

"textAnswer": "Константы и переменные"

}

],

"hint": "Свойства и методы. Классы и структуры являются универсальными и гибкими конструкциями, которые станут строительными блоками вашей программы."

},

{

"id": 1303,

"textQuestion": "Требует ли Swift создавать отдельные файлы для интерфейсов и реализаций пользовательских классов и структур?",

"answers": [

{

"correctAnswer" : true,

"textAnswer": "Нет"

},

{

"textAnswer": "Да"

}

],

"hint": "Нет. В отличие от других языков программирования, Swift не требует создавать отдельные файлы для интерфейсов и реализаций пользовательских классов и структур."

},

{

"id": 1304,

"textQuestion": "Как традиционно называют экземпляр класса в ООП?",

"answers": [

{

"textAnswer": "Экземпляр"

},

{

"correctAnswer" : true,

"textAnswer": "Объект"

},

{

"textAnswer": "Таргет"

},

{

"textAnswer": "Структура"

}

],

"hint": "Объект. Экземпляр класса традиционно называют объектом."

},

{

"id": 1305,

"textQuestion": "Применима ли функциональность экземпляров класса к экземплярам структуры?",

"answers": [

{

"textAnswer": "Нет"

},

{

"correctAnswer" : true,

"textAnswer": "Да"

}

],

"hint": "Да. Экземпляр класса традиционно называют объектом. Тем не менее, классы и структуры в Swift гораздо ближе по функциональности, чем в других языках."

},

{

"id": 1306,

"textQuestion": "Основное отличие структуры от класса?",

"answers": [

{

"textAnswer": "Нельзя использовать деинициализатор"

},

{

"correctAnswer" : true,

"textAnswer": "Нельзя объявлять методы"

},

{

"textAnswer": "Нельзя объявлять свойства"

},

{

"correctAnswer" : true,

"textAnswer": "Нельзя объявлять инициализаторы"

}

],

"hint": "Нельзя использовать деинициализатор. Вы не можете использовать деинициализатор у структуры. Классы и структуры в Swift имеют много общего. И в классах и в структурах можно: Объявлять свойства для хранения значений."

},

{

"id": 1307,

"textQuestion": "Могут ли структуры соответствовать протоколам, чтобы обеспечивать стандартную функционального определенного типа?",

"answers": [

{

"textAnswer": "Нет"

},

{

"correctAnswer" : true,

"textAnswer": "Да"

}

],

"hint": "Да. Классы и структуры в Swift имеют много общего, в том числе, они могут соответствовать протоколам, для обеспечения стандартной функциональности определенного типа."

},

{

"id": 1308,

"textQuestion": "С чем связаны дополнительные возможности поддержки классов в Swift?",

"answers": [

{

"textAnswer": "С архитектурой языка"

},

{

"textAnswer": "Со снижением сложности"

},

{

"correctAnswer" : true,

"textAnswer": "С увеличением сложности"

}

],

"hint": "Лучше использовать структуры и перечисления, потому что их легче понимать. Также не забывайте про классы. На практике - большинство пользовательских типов данных, с которыми вы работаете - это структуры и перечисления."

},

{

"id": 1309,

"textQuestion": "Именна классов и структур в Swift должны начинаться с UpperCamelCase или lowerCamelCase?",

"answers": [

{

"textAnswer": "Зависит от команды"

},

{

"textAnswer": "lowerCamelCase"

},

{

"correctAnswer" : true,

"textAnswer": "UpperCamelCase"

},

{

"textAnswer": "Без разницы"

}

],

"hint": "UpperCamelCase. Чего бы вы не создавали, новый класс или структуру, вы фактически создаете новый тип в Swift. Назначайте имена типов исмпользуя UpperCamelCase."

},

{

"id": 1310,

"textQuestion": "Именна свойств и методов в Swift должны начинаться с UpperCamelCase или lowerCamelCase?",

"answers": [

{

"textAnswer": "Зависит от команды"

},

{

"correctAnswer" : true,

"textAnswer": "lowerCamelCase"

},

{

"textAnswer": "UpperCamelCase"

},

{

"textAnswer": "На ваше усмотрение"

}

],

"hint": "lowerCamelCase. Всегда назначайте свойствам и методам имена в lowerCamelCase."

},

{

"id": 1311,

"textQuestion": "Сами по себе класы или структуры описывают специфику каких-либо объектов?",

"answers": [

{

"textAnswer": "Только структуры"

},

{

"textAnswer": "Да"

},

{

"textAnswer": "Только классы"

},

{

"correctAnswer" : true,

"textAnswer": "Нет"

}

],

"hint": "Нет. Сами по себе классы и структуры не описывают специфику каких-либо объектов. Для того, чтобы это сделать нам нужно создать экземпляр структуры или класса."

},

{

"id": 1312,

"textQuestion": "Чтобы создать экземпляр класса, какой синтаксис необходимо использовать?",

"answers": [

{

"textAnswer": "Name = ()"

},

{

"textAnswer": "Name[]"

},

{

"correctAnswer" : true,

"textAnswer": "Name()"

},

{

"textAnswer": "(Name)[]"

}

],

"hint": "Name(). И класы и структуры используют синтаксис инициализаторы для образования новых экземпляров. Самая простая форма синтаксиса инициализ"

},

{

"id": 1313,

"textQuestion": "Как мы можем получить доступ к свойствам экземпляра?",

"answers": [

{

"correctAnswer" : true,

"textAnswer": "Точечный синтаксис"

},

{

"textAnswer": "Синтаксис деинициализатора"

},

{

"textAnswer": "Синтаксис инициализации"

},

{

"textAnswer": "Синтаксис индексов"

}

],

"hint": "Точечный синтаксис. Вы можете получить доступ к свойствам экземпляра, используя точечный синтаксис. В точечном синтаксисе имя свойства пишется сразу после имени экземпляра, а между ними вписывается точка (.) без пробелов"

},

{

"id": 1314,

"textQuestion": "Можем ли мы присваивать новое значение свойству экземпляра через точечный синтаксис?",

"answers": [

{

"correctAnswer" : true,

"textAnswer": "Если оно является переменной"

},

{

"textAnswer": "нет"

},

{

"textAnswer": "Можем всегда"

}

],

"hint": "Если оно является переменной. Вы можете использовать точечный синтаксис для присваивания нового значения свойству экземпляра. Только если это свойство - переменная, а не константа."

},

{

"id": 1315,

"textQuestion": "У структур и у классов есть поэлементный, автоматически сгенерированный инициализатор, так ли это?",

"answers": [

{

"textAnswer": "Только у классов"

},

{

"textAnswer": "И у структур и у классов"

},

{

"textAnswer": "Нет"

},

{

"correctAnswer" : true,

"textAnswer": "Только у структур"

}

],

"hint": "Только у структур. Все структуры имеют автоматически сгенерированный, который вы можете использовать для инициализации свойств новых экземпляров структуры."

},

{

"id": 1316,

"textQuestion": "Что из перечисленного является типом значения?",

"answers": [

{

"textAnswer": "Классы и перечисления"

},

{

"correctAnswer" : true,

"textAnswer": "Структуры и перечисления"

},

{

"textAnswer": "Структуры и классы"

}

],

"hint": "Структуры и перечисления. Тип значения - это тип, значения которого копируется, когда оно присваивается константе или переменной, или когда передается функции."

},

{

"id": 1317,

"textQuestion": "Каким образом реализованы все базовые типы в Swift?",

"answers": [

{

"textAnswer": "Как сабклассы"

},

{

"correctAnswer" : true,

"textAnswer": "Как структуры"

},

{

"textAnswer": "Как методы"

},

{

"textAnswer": "Как классы"

}

],

"hint": "Как структуры. Все базовые типы Swift - типы значений и реализованы они как структуры."

},

{

"id": 1318,

"textQuestion": "У стандартных типов коллекций в Swift есть оптимизация, позволяющая сократить затраты на копирование большого количества элементов, из-за нее элементы копируются?",

"answers": [

{

"correctAnswer" : true,

"textAnswer": "Прямо перед модификацией"

},

{

"textAnswer": "Специальным алгоритмом"

},

{

"textAnswer": "В глобальном потоке"

},

{

"textAnswer": "Не копируется"

}

],

"hint": "Прямо перед модификацией. Коллекции, определенные стандартной библиотекой, такие как массивы, словари и строки, используют оптимизацию для снижения затрат на копирование."

},

{

"id": 1319,

"textQuestion": "Что из перечисленного является ссылочным типом?",

"answers": [

{

"textAnswer": "Структуры"

},

{

"correctAnswer" : true,

"textAnswer": "Классы"

},

{

"textAnswer": "Свойства"

},

{

"textAnswer": "Перечисления"

}

],

"hint": "Классы. Классы - ссылочный тип. В отличии от типа значений, ссылочный тип не копируется, когде его присваивают переменной или константе, или когда его передают функции."

},

{

"id": 1320,

"textQuestion": "В чем сложность работы со ссылочными типами?",

"answers": [

{

"textAnswer": "Проблематичнее поддерживать"

},

{

"correctAnswer" : true,

"textAnswer": "Трудно отследить изменения"

},

{

"textAnswer": "Создается много копий"

}

],

"hint": "Трудно отследить изменения. Бывает очень сложно следить за ссылочными типами. Если две разные переменные, ссылающиеся на один экземпляр, находились бы в разны уголках вашей программы, то было бы сложно найти все места, где мы их меняем."

},

{

"id": 1321,

"textQuestion": "Как проверить ссылаются ли несколько констант или переменных на один экземпляр класса или нет?",

"answers": [

{

"textAnswer": "Через инструкцию if"

},

{

"textAnswer": "Оператор сравнения =="

},

{

"correctAnswer" : true,

"textAnswer": "Оператор тождественности ==="

},

{

"textAnswer": "Оператор присваивания"

}

],

"hint": "Оператор  тождественности ===. Так как классы являются ссылочными типами, то есть возможность сделать так, чтобы несколько констант и переменных ссылались на один единственный экземпляр класса."

}

]

}
